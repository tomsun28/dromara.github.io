<!doctype html><html><head><title>Hmily: 高性能异步分布式事务TCC框架 · dromara(Open source organization)</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="The girl on the prairie"><meta name=wwads-cn-verify content=8d5e957f297893487bd98fa830fa6413><meta name=generator content="Hugo 0.55.5"><link rel="shortcut icon" href=/img/favicon.png type=image/png><link href=https://unpkg.com/purecss@1.0.0/build/base-min.css rel=stylesheet><link href=/css/main.css rel=stylesheet><link href=/css/zoom-image.css rel=stylesheet><script src=/js/iconfont.js></script><script src=/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script>window.SITE_LANGUAGE="zh"</script><script src=/js/app.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?a02cb5c75097762223d5a815a03e0a15";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><script type=text/javascript src=https://cdn.wwads.cn/js/makemoney.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-187960192-2','auto');ga('send','pageview');}</script></head><body><header class=ss-header><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class=logo-link href=/zh/><img class=logo src=/img/logo/dromara.jpg></a><div class=-show-mobile><a id=mobile-menu-icon><svg class="icon" aria-hidden="true"><use xlink:href="#icon-menu"/></svg></a><nav id=mobile-menu><div id=js-menu-search-mobile class=navbar-search-mobile><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div><a href=/zh/projects/><span>项目</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/blog/><span>博客</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/activities/><span>活动</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/community/><span>社区</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/zh/awesome/><span>Awesome Dromara</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-ARROW"/></svg></a>
<a href=/blog/hmily_introduction/><span>English</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-transfer"/></svg></a></nav></div></div><div class="navbar-menu -hidden-mobile"><div class=navbar-start><a class=navbar-item href=/zh/projects/>项目</a>
<a class=navbar-item href=/zh/blog/>博客</a>
<a class=navbar-item href=/zh/activities/>活动</a>
<a class=navbar-item href=/zh/community/>社区</a>
<a class=navbar-item href=/zh/awesome/>Awesome Dromara</a></div><div class=navbar-end><div class=navbar-item><div id=js-menu-search class=navbar-search><input class=input placeholder=请输入要搜索的关键词><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search"/></svg></div></div><div class=navbar-item><a class=translation href=/blog/hmily_introduction/>En</a></div></div></div></nav></header><div class=ss-layout-container><main class="ss-layout-main -card"><div class=ss-meta><h1 class=title>Hmily: 高性能异步分布式事务TCC框架</h1><div class=meta>2018-09-25 ·
xiaoyu ·
<span class=tags><a class=tag href=/zh/tags/hmily/ rel=tag>#hmily</a>
<a class=tag href=/zh/tags/tcc/ rel=tag>#TCC</a></span></div></div><article class=typo><h1 id=hmily框架特性-https-github-com-yu199195-hmily>Hmily框架特性[<a href=https://github.com/yu199195/hmily>https://github.com/yu199195/hmily</a>]</h1><ul><li><p>无缝集成Spring,Spring boot start。</p></li><li><p>无缝集成Dubbo,SpringCloud,Motan等rpc框架。</p></li><li><p>多种事务日志的存储方式（redis，mongdb,mysql等）。</p></li><li><p>多种不同日志序列化方式（Kryo,protostuff,hession）。</p></li><li><p>事务自动恢复。</p></li><li><p>支持内嵌事务的依赖传递。</p><ul><li>代码零侵入,配置简单灵活。</li></ul></li></ul><h1 id=hmily为什么这么高性能>Hmily为什么这么高性能？</h1><h3 id=1-采用disruptor进行事务日志的异步读写-disruptor是一个无锁-无gc的并发编程框架>1.采用disruptor进行事务日志的异步读写（disruptor是一个无锁，无GC的并发编程框架）</h3><pre><code class=language-java>package com.hmily.tcc.core.disruptor.publisher;

import com.hmily.tcc.common.bean.entity.TccTransaction;
import com.hmily.tcc.common.enums.EventTypeEnum;
import com.hmily.tcc.core.concurrent.threadpool.HmilyThreadFactory;
import com.hmily.tcc.core.coordinator.CoordinatorService;
import com.hmily.tcc.core.disruptor.event.HmilyTransactionEvent;
import com.hmily.tcc.core.disruptor.factory.HmilyTransactionEventFactory;
import com.hmily.tcc.core.disruptor.handler.HmilyConsumerDataHandler;
import com.hmily.tcc.core.disruptor.translator.HmilyTransactionEventTranslator;
import com.lmax.disruptor.BlockingWaitStrategy;
import com.lmax.disruptor.IgnoreExceptionHandler;
import com.lmax.disruptor.RingBuffer;
import com.lmax.disruptor.dsl.Disruptor;
import com.lmax.disruptor.dsl.ProducerType;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * event publisher.
 *
 * @author xiaoyu(Myth)
 */
@Component
public class HmilyTransactionEventPublisher implements DisposableBean {

    private Disruptor&lt;HmilyTransactionEvent&gt; disruptor;

    private final CoordinatorService coordinatorService;

    @Autowired
    public HmilyTransactionEventPublisher(final CoordinatorService coordinatorService) {
        this.coordinatorService = coordinatorService;
    }

    /**
     * disruptor start.
     *
     * @param bufferSize this is disruptor buffer size.
     * @param threadSize this is disruptor consumer thread size.
     */
    public void start(final int bufferSize, final int threadSize) {
        disruptor = new Disruptor&lt;&gt;(new HmilyTransactionEventFactory(), bufferSize, r -&gt; {
            AtomicInteger index = new AtomicInteger(1);
            return new Thread(null, r, &quot;disruptor-thread-&quot; + index.getAndIncrement());
        }, ProducerType.MULTI, new BlockingWaitStrategy());

        final Executor executor = new ThreadPoolExecutor(threadSize, threadSize, 0, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue&lt;&gt;(),
                HmilyThreadFactory.create(&quot;hmily-log-disruptor&quot;, false),
                new ThreadPoolExecutor.AbortPolicy());

        HmilyConsumerDataHandler[] consumers = new HmilyConsumerDataHandler[threadSize];
        for (int i = 0; i &lt; threadSize; i++) {
            consumers[i] = new HmilyConsumerDataHandler(executor, coordinatorService);
        }
        disruptor.handleEventsWithWorkerPool(consumers);
        disruptor.setDefaultExceptionHandler(new IgnoreExceptionHandler());
        disruptor.start();
    }

    /**
     * publish disruptor event.
     *
     * @param tccTransaction {@linkplain com.hmily.tcc.common.bean.entity.TccTransaction }
     * @param type           {@linkplain EventTypeEnum}
     */
    public void publishEvent(final TccTransaction tccTransaction, final int type) {
        final RingBuffer&lt;HmilyTransactionEvent&gt; ringBuffer = disruptor.getRingBuffer();
        ringBuffer.publishEvent(new HmilyTransactionEventTranslator(type), tccTransaction);
    }

    @Override
    public void destroy() {
        disruptor.shutdown();
    }
}
</code></pre><ul><li>在这里bufferSize 的默认值是4094 * 4,用户可以根据自行的情况进行配置。
```java</li></ul><p>HmilyConsumerDataHandler[] consumers = new HmilyConsumerDataHandler[threadSize];
for (int i = 0; i &lt; threadSize; i++) {
consumers[i] = new HmilyConsumerDataHandler(executor, coordinatorService);
}
disruptor.handleEventsWithWorkerPool(consumers);</p><pre><code>* 这里是采用多个消费者去处理队列里面的任务。

### 2.异步执行confrim,cancel方法。
```java
package com.hmily.tcc.core.service.handler;

import com.hmily.tcc.common.bean.context.TccTransactionContext;
import com.hmily.tcc.common.bean.entity.TccTransaction;
import com.hmily.tcc.common.enums.TccActionEnum;
import com.hmily.tcc.core.concurrent.threadpool.HmilyThreadFactory;
import com.hmily.tcc.core.service.HmilyTransactionHandler;
import com.hmily.tcc.core.service.executor.HmilyTransactionExecutor;
import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * this is transaction starter.
 *
 * @author xiaoyu
 */
@Component
public class StarterHmilyTransactionHandler implements HmilyTransactionHandler {

    private static final int MAX_THREAD = Runtime.getRuntime().availableProcessors() &lt;&lt; 1;

    private final HmilyTransactionExecutor hmilyTransactionExecutor;

    private final Executor executor = new ThreadPoolExecutor(MAX_THREAD, MAX_THREAD, 0, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue&lt;&gt;(),
            HmilyThreadFactory.create(&quot;hmily-execute&quot;, false),
            new ThreadPoolExecutor.AbortPolicy());

    @Autowired
    public StarterHmilyTransactionHandler(final HmilyTransactionExecutor hmilyTransactionExecutor) {
        this.hmilyTransactionExecutor = hmilyTransactionExecutor;
    }

    @Override
    public Object handler(final ProceedingJoinPoint point, final TccTransactionContext context)
            throws Throwable {
        Object returnValue;
        try {
            TccTransaction tccTransaction = hmilyTransactionExecutor.begin(point);
            try {
                //execute try
                returnValue = point.proceed();
                tccTransaction.setStatus(TccActionEnum.TRYING.getCode());
                hmilyTransactionExecutor.updateStatus(tccTransaction);
            } catch (Throwable throwable) {
                //if exception ,execute cancel
                final TccTransaction currentTransaction = hmilyTransactionExecutor.getCurrentTransaction();
                executor.execute(() -&gt; hmilyTransactionExecutor
                        .cancel(currentTransaction));
                throw throwable;
            }
            //execute confirm
            final TccTransaction currentTransaction = hmilyTransactionExecutor.getCurrentTransaction();
            executor.execute(() -&gt; hmilyTransactionExecutor.confirm(currentTransaction));
        } finally {
            hmilyTransactionExecutor.remove();
        }
        return returnValue;
    }
}
</code></pre><ul><li>当try方法的AOP切面有异常的时候，采用线程池异步去执行cancel，无异常的时候去执行confrim方法。</li></ul><h3 id=这里有人可能会问-那么cancel方法异常-或者confrim方法异常怎么办呢>这里有人可能会问：那么cancel方法异常，或者confrim方法异常怎么办呢？</h3><p>答：首先这种情况是非常罕见的，因为你上一面才刚刚执行完try。其次如果出现这种情况，在try阶段会保存好日志，Hmily有内置的调度线程池来进行恢复，不用担心。</p><h3 id=有人又会问-这里如果日志保存异常了怎么办>有人又会问：这里如果日志保存异常了怎么办？</h3><p>答：首先这又是一个牛角尖问题，首先日志配置的参数，在框架启动的时候，会要求你配置的。其次，就算在运行过程中日志保存异常，这时候框架会取缓存中的，并不会影响程序正确执行。最后，万一日志保存异常了，系统又在很极端的情况下down机了，恭喜你，你可以去买彩票了，最好的解决办法就是不去解决它。</p><h3 id=3-threadlocal缓存的使用>3.ThreadLocal缓存的使用。</h3><pre><code class=language-java>  /**
     * transaction begin.
     *
     * @param point cut point.
     * @return TccTransaction
     */
    public TccTransaction begin(final ProceedingJoinPoint point) {
        LogUtil.debug(LOGGER, () -&gt; &quot;......hmily transaction！start....&quot;);
        //build tccTransaction
        final TccTransaction tccTransaction = buildTccTransaction(point, TccRoleEnum.START.getCode(), null);
        //save tccTransaction in threadLocal
        CURRENT.set(tccTransaction);
        //publishEvent
        hmilyTransactionEventPublisher.publishEvent(tccTransaction, EventTypeEnum.SAVE.getCode());
        //set TccTransactionContext this context transfer remote
        TccTransactionContext context = new TccTransactionContext();
        //set action is try
        context.setAction(TccActionEnum.TRYING.getCode());
        context.setTransId(tccTransaction.getTransId());
        context.setRole(TccRoleEnum.START.getCode());
        TransactionContextLocal.getInstance().set(context);
        return tccTransaction;
    }
</code></pre><ul><li>首先要理解，threadLocal保存的发起者一方法的事务信息。这个很重要，不要会有点懵逼。rpc的调用，会形成调用链，进行保存。</li></ul><pre><code class=language-java>
 /**
     * add participant.
     *
     * @param participant {@linkplain Participant}
     */
    public void enlistParticipant(final Participant participant) {
        if (Objects.isNull(participant)) {
            return;
        }
        Optional.ofNullable(getCurrentTransaction())
                .ifPresent(c -&gt; {
                    c.registerParticipant(participant);
                    updateParticipant(c);
                });
    }
</code></pre><h3 id=4-guavacache的使用>4.GuavaCache的使用</h3><pre><code class=language-java>package com.hmily.tcc.core.cache;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.cache.Weigher;
import com.hmily.tcc.common.bean.entity.TccTransaction;
import com.hmily.tcc.core.coordinator.CoordinatorService;
import com.hmily.tcc.core.helper.SpringBeanUtils;
import org.apache.commons.lang3.StringUtils;

import java.util.Optional;
import java.util.concurrent.ExecutionException;

/**
 * use google guava cache.
 * @author xiaoyu
 */
public final class TccTransactionCacheManager {

    private static final int MAX_COUNT = 10000;

    private static final LoadingCache&lt;String, TccTransaction&gt; LOADING_CACHE =
            CacheBuilder.newBuilder().maximumWeight(MAX_COUNT)
                    .weigher((Weigher&lt;String, TccTransaction&gt;) (string, tccTransaction) -&gt; getSize())
                    .build(new CacheLoader&lt;String, TccTransaction&gt;() {
                        @Override
                        public TccTransaction load(final String key) {
                            return cacheTccTransaction(key);
                        }
                    });

    private static CoordinatorService coordinatorService = SpringBeanUtils.getInstance().getBean(CoordinatorService.class);

    private static final TccTransactionCacheManager TCC_TRANSACTION_CACHE_MANAGER = new TccTransactionCacheManager();

    private TccTransactionCacheManager() {

    }

    /**
     * TccTransactionCacheManager.
     *
     * @return TccTransactionCacheManager
     */
    public static TccTransactionCacheManager getInstance() {
        return TCC_TRANSACTION_CACHE_MANAGER;
    }

    private static int getSize() {
        return (int) LOADING_CACHE.size();
    }

    private static TccTransaction cacheTccTransaction(final String key) {
        return Optional.ofNullable(coordinatorService.findByTransId(key)).orElse(new TccTransaction());
    }

    /**
     * cache tccTransaction.
     *
     * @param tccTransaction {@linkplain TccTransaction}
     */
    public void cacheTccTransaction(final TccTransaction tccTransaction) {
        LOADING_CACHE.put(tccTransaction.getTransId(), tccTransaction);
    }

    /**
     * acquire TccTransaction.
     *
     * @param key this guava key.
     * @return {@linkplain TccTransaction}
     */
    public TccTransaction getTccTransaction(final String key) {
        try {
            return LOADING_CACHE.get(key);
        } catch (ExecutionException e) {
            return new TccTransaction();
        }
    }

    /**
     * remove guava cache by key.
     * @param key guava cache key.
     */
    public void removeByKey(final String key) {
        if (StringUtils.isNotEmpty(key)) {
            LOADING_CACHE.invalidate(key);
        }
    }

}
</code></pre><ul><li><p>在参与者中，我们使用了ThreadLocal，而在参与者中，我们为什么不使用呢？
其实原因有二点：首先.因为try，和confrim 会不在一个线程里，会造成ThreadLocal失效。当考虑到RPC集群的时候，可能会负载到不同的机器上。这里有一个细节就是：</p><pre><code class=language-java>private static TccTransaction cacheTccTransaction(final String key) {
    return Optional.ofNullable(coordinatorService.findByTransId(key)).orElse(new TccTransaction());
}
</code></pre><p>当GuavaCache里面没有的时候，会去查询日志返回，这样就保证了对集群环境的支持。</p><h3 id=以上4点造就了hmily是一个异步的高性能分布式事务tcc框架的原因>以上4点造就了Hmily是一个异步的高性能分布式事务TCC框架的原因。</h3><h3 id=hmily如何使用-https-github-com-yu199195-hmily-tree-master-hmily-tcc-demo>Hmily如何使用？（<a href=https://github.com/yu199195/hmily/tree/master/hmily-tcc-demo）>https://github.com/yu199195/hmily/tree/master/hmily-tcc-demo）</a></h3><p>首先因为之前的包命名问题，框架包并没有上传到maven中心仓库，固需要使用者自己拉取代码，编译deploy到自己的私服。</p><h3 id=1-dubbo用户>1.dubbo用户</h3><ul><li>在你的Api接口项目引入
```xml</li></ul><p><dependency><groupid>com.hmily.tcc</groupid>
<artifactid>hmily-tcc-annotation</artifactid>
<version>{you version}</version></dependency>
```</p></li><li><p>在你的服务提供者项目引入</p></li></ul><pre><code class=language-xml> &lt;dependency&gt;
            &lt;groupId&gt;com.hmily.tcc&lt;/groupId&gt;
            &lt;artifactId&gt;hmily-tcc-dubbo&lt;/artifactId&gt;
            &lt;version&gt;{you version}&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><ul><li>配置启动bean
```xml</li></ul><p><aop:aspectj-autoproxy expose-proxy=true><context:component-scan base-package=com.hmily.tcc.*><bean id=hmilyTransactionBootstrap class=com.hmily.tcc.core.bootstrap.HmilyTransactionBootstrap><property name=serializer value=kryo><property name=recoverDelayTime value=120><property name=retryMax value=3><property name=scheduledDelay value=120><property name=scheduledThreadMax value=4><property name=repositorySupport value=db><property name=tccDbConfig><bean class=com.hmily.tcc.common.config.TccDbConfig><property name=url value="jdbc:mysql://192.168.1.98:3306/tcc?useUnicode=true&amp;characterEncoding=utf8"><property name=driverClassName value=com.mysql.jdbc.Driver><property name=username value=root><property name=password value=123456></bean></property></bean></p><pre><code>* 当然配置属性很多，这里我只给出了demo，具体可以参考这个类：

```java
package com.hmily.tcc.common.config;

import com.hmily.tcc.common.enums.RepositorySupportEnum;
import lombok.Data;

/**
 * hmily config.
 *
 * @author xiaoyu
 */
@Data
public class TccConfig {


    /**
     * Resource suffix this parameter please fill in about is the transaction store path.
     * If it's a table store this is a table suffix, it's stored the same way.
     * If this parameter is not filled in, the applicationName of the application is retrieved by default
     */
    private String repositorySuffix;

    /**
     * log serializer.
     * {@linkplain com.hmily.tcc.common.enums.SerializeEnum}
     */
    private String serializer = &quot;kryo&quot;;

    /**
     * scheduledPool Thread size.
     */
    private int scheduledThreadMax = Runtime.getRuntime().availableProcessors() &lt;&lt; 1;

    /**
     * scheduledPool scheduledDelay unit SECONDS.
     */
    private int scheduledDelay = 60;

    /**
     * retry max.
     */
    private int retryMax = 3;

    /**
     * recoverDelayTime Unit seconds
     * (note that this time represents how many seconds after the local transaction was created before execution).
     */
    private int recoverDelayTime = 60;

    /**
     * Parameters when participants perform their own recovery.
     * 1.such as RPC calls time out
     * 2.such as the starter down machine
     */
    private int loadFactor = 2;

    /**
     * repositorySupport.
     * {@linkplain RepositorySupportEnum}
     */
    private String repositorySupport = &quot;db&quot;;

    /**
     * disruptor bufferSize.
     */
    private int bufferSize = 4096 * 2 * 2;

    /**
     * this is disruptor consumerThreads.
     */
    private int consumerThreads = Runtime.getRuntime().availableProcessors() &lt;&lt; 1;

    /**
     * db config.
     */
    private TccDbConfig tccDbConfig;

    /**
     * mongo config.
     */
    private TccMongoConfig tccMongoConfig;

    /**
     * redis config.
     */
    private TccRedisConfig tccRedisConfig;

    /**
     * zookeeper config.
     */
    private TccZookeeperConfig tccZookeeperConfig;

    /**
     * file config.
     */
    private TccFileConfig tccFileConfig;

}
</code></pre><h3 id=springcloud用户>SpringCloud用户</h3><pre><code class=language-xml>     &lt;dependency&gt;
          &lt;groupId&gt;com.hmily.tcc&lt;/groupId&gt;
          &lt;artifactId&gt;hmily-tcc-springcloud&lt;/artifactId&gt;
          &lt;version&gt;{you version}&lt;/version&gt;
      &lt;/dependency&gt;
</code></pre><h3 id=motan用户>Motan用户</h3><pre><code class=language-xml>     &lt;dependency&gt;
          &lt;groupId&gt;com.hmily.tcc&lt;/groupId&gt;
          &lt;artifactId&gt;hmily-tcc-motan&lt;/artifactId&gt;
          &lt;version&gt;{you version}&lt;/version&gt;
      &lt;/dependency&gt;
</code></pre><h3 id=hmily-spring-boot-start那这个就更容易了-只需要根据你的rpc框架去引入不同的jar包>hmily-spring-boot-start那这个就更容易了，只需要根据你的RPC框架去引入不同的jar包。</h3><ul><li><p>如果你是dubbo用户，那么引入</p><pre><code class=language-xml>&lt;dependency&gt;
 &lt;groupId&gt;com.hmily.tcc&lt;/groupId&gt;
 &lt;artifactId&gt;hmily-tcc-spring-boot-starter-dubbo&lt;/artifactId&gt;
 &lt;version&gt;${your version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><ul><li>如果你是SpringCloud用户，那么引入</li></ul><pre><code class=language-xml>&lt;dependency&gt;
 &lt;groupId&gt;com.hmily.tcc&lt;/groupId&gt;
 &lt;artifactId&gt;hmily-tcc-spring-boot-starter-springcloud&lt;/artifactId&gt;
 &lt;version&gt;${your version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li><li><p>如果你是Motan用户，那么引入:</p></li></ul><pre><code class=language-xml>&lt;dependency&gt;
     &lt;groupId&gt;com.hmily.tcc&lt;/groupId&gt;
     &lt;artifactId&gt;hmily-tcc-spring-boot-starter-motan&lt;/artifactId&gt;
     &lt;version&gt;${your version}&lt;/version&gt;
 &lt;/dependency&gt;
</code></pre><ul><li><p>然后在你的yml里面进行如下配置：</p><pre><code class=language-yml>hmily:
tcc :
    serializer : kryo
    recoverDelayTime : 128
    retryMax : 3
    scheduledDelay : 128
    scheduledThreadMax :  10
    repositorySupport : db
    tccDbConfig :
             driverClassName  : com.mysql.jdbc.Driver
             url :  jdbc:mysql://192.168.1.98:3306/tcc?useUnicode=true&amp;amp;characterEncoding=utf8
             username : root
             password : 123456

    #repositorySupport : redis
    #tccRedisConfig:
             #masterName: mymaster
             #sentinel : true
             #sentinelUrl : 192.168.1.91:26379;192.168.1.92:26379;192.168.1.93:26379
             #password  : foobaredbbexONE123


   # repositorySupport : zookeeper
   #         host      : 92.168.1.73:2181
   #         sessionTimeOut      :  100000
   #         rootPath  : /tcc

   # repositorySupport : mongodb
   #       mongoDbUrl  : 192.168.1.68:27017
   #       mongoDbName  :  happylife
   #       mongoUserName  : xiaoyu
   #       mongoUserPwd   : 123456

   # repositorySupport : file
   #         path      : /account
   #         prefix    :  account
</code></pre><ul><li><p>就这么简单，然后就可以在接口方法上加上@Tcc注解，进行愉快的使用了。</p></li><li><p>当然因为篇幅问题，很多东西只是简单的描述，尤其是逻辑方面的。</p></li><li><p>如果你感兴趣，可以在github上进行star和fork，也可以加微信和QQ群进行交流。</p></li><li><p>下面是github地址：<a href=https://github.com/yu199195/hmily>https://github.com/yu199195/hmily</a></p></li><li><p>最后再次感谢大家，如果有兴趣的朋友，可以提供你的优秀牛逼轰轰的PR。。。。</p></li></ul></li></ul></article><div class="wwads-cn wwads-horizontal" data-id=127 style=max-width:500px></div><div class=-show-mobile><nav class=ss-pagination-next><a class=link-next href=/zh/blog/hmily_current/><span class=text>下一篇:</span>
<span class=text>Hmily: 轻松搞定高并发分布式事务</span></a></nav></div></main><aside class=ss-layout-aside><div class="ss-aside-tags ss-card"><h2 class=card-title>标签
<span class=card-extra></span></h2><ul class=tag-list><li class=tag><a href=/zh/tags/dreamcode/>DreamCode</a></li><li class=tag><a href=/zh/tags/dromara/>Dromara</a></li><li class=tag><a href=/zh/tags/gateway/>GateWay</a></li><li class=tag><a href=/zh/tags/hmily/>hmily</a></li><li class=tag><a href=/zh/tags/hutool/>hutool</a></li><li class=tag><a href=/zh/tags/reactor/>Reactor</a></li><li class=tag><a href=/zh/tags/soul/>Soul</a></li><li class=tag><a href=/zh/tags/tcc/>TCC</a></li></ul></div></aside></div><footer class=ss-footer><div class=container><div class=links><div class=cate><h2 class=cate-title>资源</h2><a class=link href=https://github.com/dromara>Github</a>
<a class=link href=https://gitee.com/dromara>Gitee</a></div><div class=cate><h2 class=cate-title>参与进来</h2><a class=link href=https://github.com/dromara/soul/issues/new>反馈</a>
<a class=link href=/zh/community>社区</a>
<a class=link href=/zh/blog>博客</a></div><div class=cate><h2 class=cate-title>文档</h2><a class=link href=/zh/projects/hmily/overview/>Hmily</a>
<a class=link href=/zh/projects/raincat/overview/>Raincat</a>
<a class=link href=/zh/projects/myth/overview/>Myth</a></div></div><div class=qrcode><div><img class=qrcode-img src=/img/qrcode/qrcode_1.png><p class=qrcode-desc>微信公众号</p></div><div><img class=qrcode-img src=/img/qrcode/qrcode_2.png><p class=qrcode-desc>QQ群</p></div><div><img class=qrcode-img src=/img/qrcode/zsxq.png><p class=qrcode-desc>知识星球</p></div></div></div><div class=copyright><p>Copyright ©2021
<a href=/>@dromara. org. All Rights Reserved</a></p></div></footer></body></html>